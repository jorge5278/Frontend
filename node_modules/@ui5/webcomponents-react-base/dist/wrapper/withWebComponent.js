'use client';
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { getEffectiveScopingSuffixForTag } from '@ui5/webcomponents-base/dist/CustomElementsScope.js';
import { cloneElement, forwardRef, Fragment, isValidElement, useEffect, useState, version } from 'react';
import { useIsomorphicLayoutEffect } from '../hooks/useIsomorphicLayoutEffect.js';
import { useSyncRef } from '../hooks/useSyncRef.js';
import { camelToKebabCase, capitalizeFirstLetter, kebabToCamelCase, parseSemVer } from '../utils/index.js';
const createEventPropName = (eventName) => `on${capitalizeFirstLetter(kebabToCamelCase(eventName))}`;
const isPrimitiveAttribute = (value) => {
    return typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean';
};
const definedWebComponents = new Set([]);
export const withWebComponent = (tagName, regularProperties, booleanProperties, slotProperties, eventProperties) => {
    const webComponentsSupported = parseSemVer(version).major >= 19;
    // displayName will be assigned in the individual files
    // eslint-disable-next-line react/display-name
    return forwardRef((props, wcRef) => {
        const { className, children, waitForDefine, ...rest } = props;
        const [componentRef, ref] = useSyncRef(wcRef);
        const tagNameSuffix = getEffectiveScopingSuffixForTag(tagName);
        const Component = (tagNameSuffix ? `${tagName}-${tagNameSuffix}` : tagName);
        const [isDefined, setIsDefined] = useState(definedWebComponents.has(Component));
        // regular props (no booleans, no slots and no events)
        const regularProps = regularProperties.reduce((acc, name) => {
            if (Object.prototype.hasOwnProperty.call(rest, name) && isPrimitiveAttribute(rest[name])) {
                return { ...acc, [camelToKebabCase(name)]: rest[name] };
            }
            return acc;
        }, {});
        // boolean properties - only attach if they are truthy
        const booleanProps = booleanProperties.reduce((acc, name) => {
            if (webComponentsSupported) {
                return { ...acc, [camelToKebabCase(name)]: rest[name] };
            }
            else {
                if (rest[name] === true || rest[name] === 'true') {
                    return { ...acc, [camelToKebabCase(name)]: true };
                }
                return acc;
            }
        }, {});
        const slots = slotProperties.reduce((acc, name) => {
            const slotValue = rest[name];
            if (!slotValue) {
                return acc;
            }
            if (rest[name]?.$$typeof === Symbol.for('react.portal')) {
                console.warn('ReactPortal is not supported for slot props.');
                return acc;
            }
            const slottedChildren = [];
            let index = 0;
            const removeFragments = (element) => {
                if (!isValidElement(element))
                    return;
                if (element.type === Fragment) {
                    const elementChildren = element.props?.children;
                    if (Array.isArray(elementChildren)) {
                        elementChildren.forEach((item) => {
                            if (Array.isArray(item)) {
                                item.forEach(removeFragments);
                            }
                            else {
                                removeFragments(item);
                            }
                        });
                    }
                    else {
                        removeFragments(elementChildren);
                    }
                }
                else {
                    slottedChildren.push(cloneElement(element, {
                        key: element.key ?? `${name}-${index}`,
                        slot: name
                    }));
                    index++;
                }
            };
            if (Array.isArray(slotValue)) {
                slotValue.forEach((item) => {
                    removeFragments(item);
                });
            }
            else {
                removeFragments(slotValue);
            }
            return [...acc, ...slottedChildren];
        }, []);
        // event binding
        useIsomorphicLayoutEffect(() => {
            if (webComponentsSupported) {
                return () => {
                    // React can handle events
                };
            }
            const localRef = ref.current;
            const eventRegistry = {};
            if (!waitForDefine || isDefined) {
                eventProperties.forEach((eventName) => {
                    const eventHandler = rest[createEventPropName(eventName)];
                    if (typeof eventHandler === 'function') {
                        eventRegistry[eventName] = eventHandler;
                        // @ts-expect-error: all custom events can be passed here, so `keyof HTMLElementEventMap` isn't sufficient
                        localRef?.addEventListener(eventName, eventRegistry[eventName]);
                    }
                });
                return () => {
                    for (const eventName in eventRegistry) {
                        // @ts-expect-error: all custom events can be passed here, so `keyof HTMLElementEventMap` isn't sufficient
                        localRef?.removeEventListener(eventName, eventRegistry[eventName]);
                    }
                };
            }
        }, [...eventProperties.map((eventName) => rest[createEventPropName(eventName)]), isDefined, waitForDefine]);
        const eventHandlers = eventProperties.reduce((events, eventName) => {
            const eventHandlerProp = rest[createEventPropName(eventName)];
            if (webComponentsSupported && eventHandlerProp) {
                events[`on${eventName}`] = eventHandlerProp;
            }
            return events;
        }, {});
        // In React 19 events aren't correctly attached after hydration
        const [attachEvents, setAttachEvents] = useState(!webComponentsSupported || !Object.keys(eventHandlers).length); // apply workaround only for React19 and if event props are defined
        // non web component related props, just pass them
        const nonWebComponentRelatedProps = Object.entries(rest)
            .filter(([key]) => !regularProperties.includes(key))
            .filter(([key]) => !slotProperties.includes(key))
            .filter(([key]) => !booleanProperties.includes(key))
            .filter(([key]) => !eventProperties.map((eventName) => createEventPropName(eventName)).includes(key))
            .reduce((acc, [key, val]) => {
            if (!key.startsWith('aria-') && !key.startsWith('data-') && val === false) {
                return acc;
            }
            acc[key] = val;
            return acc;
        }, {});
        useEffect(() => {
            if (waitForDefine && !isDefined) {
                void customElements.whenDefined(Component).then(() => {
                    setIsDefined(true);
                    definedWebComponents.add(Component);
                });
            }
        }, [Component, waitForDefine, isDefined]);
        const propsToApply = regularProperties.map((prop) => ({ name: prop, value: props[prop] }));
        useEffect(() => {
            void customElements.whenDefined(Component).then(() => {
                for (const prop of propsToApply) {
                    if (prop.value != null && !isPrimitiveAttribute(prop.value)) {
                        if (ref.current) {
                            ref.current[prop.name] = prop.value;
                        }
                    }
                }
            });
        }, [Component, ...propsToApply]);
        useEffect(() => {
            setAttachEvents(true);
        }, []);
        if (waitForDefine && !isDefined) {
            return null;
        }
        // compatibility wrapper for ExpandableText - remove in v3
        if (tagName === 'ui5-expandable-text') {
            const renderWhiteSpace = nonWebComponentRelatedProps['renderWhitespace'] ? true : undefined;
            // @ts-expect-error: overflowMode is available
            const { ['overflow-mode']: overflowMode, text, ...restRegularProps } = regularProps;
            const showOverflowInPopover = nonWebComponentRelatedProps['showOverflowInPopover'];
            return (_jsx(Component, { ref: componentRef, ...booleanProps, ...restRegularProps, ...(attachEvents ? eventHandlers : {}), ...nonWebComponentRelatedProps, "overflow-mode": overflowMode ?? (showOverflowInPopover ? 'Popover' : 'InPlace'), 
                // @ts-expect-error: text is available
                text: text ?? children, class: className, suppressHydrationWarning: true, "data-_render-whitespace": renderWhiteSpace, children: slots }));
        }
        return (_jsxs(Component, { ref: componentRef, ...booleanProps, ...regularProps, ...(attachEvents ? eventHandlers : {}), ...nonWebComponentRelatedProps, class: className, suppressHydrationWarning: true, children: [slots, children] }));
    });
};
